
#include "../include/f_dtree.h"

F_DTree::F_DTree(DTree * tree)
{

listsubspaceTree=NULL;
//tree_temp=tree;//new DTree(*tree);
rejet_nodes=tree->getRejetNodes();
minmax=tree->getMinMax();
root_node=tree->getRoot();

//trainSet=tree->getTrainSet();
//cerr<<"creation fdtree, dim trainset:"<<trainSet->dim()<<endl;
//cin.get();


	for(v_inst_it it=tree->getTrainSet()->begin();it!=tree->getTrainSet()->end();it++)
		bag.push_back((*it)->getId());

//for(int i=0;i<bag.size();i++){
////cerr<<bag.at(i)<<"\t"<<tree->getTrainSet()->getInstance(i)->getClass()<<endl;
//cerr<<bag.at(i)<<"\t"<<tree->getTrainSet()->getInstance(i)->getOriginalId()<<endl;
//}
//cerr<<endl;

	nbNodes = tree->stat_getNbNodes();
	nbLeaves = tree->stat_getNbLeaves();
	nbLeavesTarget =  tree->stat_getNbLeavesTarget();
	nbLeavesOutlier = tree->stat_getNbLeavesOutlier();
	nbLevels = tree->stat_getNbLevels();

	if(tree->getRoot()->is_leaf())
		root = new F_Node(tree->getRoot()->getPrediction(),0);
	else
	{
		root = new F_Node(tree->getRoot()->getSplitRule(),0);
		createFDTree(tree->getRoot(),root);
	}

//delete tree_temp;
//cerr<<"f_tree created:"<<rejet_nodes<<" "<<minmax[0][0]<<endl;
}

F_DTree::F_DTree()
{
	nbNodes = 0;
	nbLeaves = 0;
	nbLeavesTarget = 0;
	nbLeavesOutlier = 0;
	nbLevels = 0;

bag.clear();
	root = NULL;


	if(listsubspaceTree!=NULL){
		delete [] listsubspaceTree;
	}

}

int F_DTree::getNbNode(){

return nbNodes;
}

int F_DTree::getNbLeaves(){

	return nbLeaves;
}

int F_DTree::getNbLeavesTarget()
{
	return nbLeavesTarget;
}

int F_DTree::getNbLeavesOutlier()
{
	return nbLeavesOutlier;
}

int F_DTree::getNbLevels()
{
	return nbLevels;
}



F_DTree::F_DTree(string filename){

	ifstream file(filename.c_str(),ios_base::in);
	if(file.is_open()){

		string line;
		getline(file,line,'\n');
		vector<string> tokens;
		Utils::tokenize(line, tokens, " ");

		for(u_int i=0;i<tokens.size();i++)
			bag.push_back((u_int) Utils::from_string(tokens[i]));

		getline(file,line,'\n');
		nbNodes = (int) Utils::from_string(line);

		map<int,F_Node *> nodes;
		map<int,int> lefts;
		map<int,int> rights;
		map<int,u_int> predictions;

		for(int i=0;i<nbNodes;i++){

			getline(file,line,'\n');

			vector<string> tokens;
			Utils::tokenize(line, tokens, " ");

			int id = (int) Utils::from_string(tokens[0]);
			if(tokens.size() == 5)
			{
				int attId = (int) Utils::from_string(tokens[1]);
				double split = Utils::from_string(tokens[2]);
				Rule * rule = new Rule(attId,split);
				F_Node * node = new F_Node(rule,id);
				nodes[id] = node;
				delete rule;

				lefts[id] = ((int) Utils::from_string(tokens[3]));
				rights[id] = ((int) Utils::from_string(tokens[4]));
			}
			else
			{
				predictions[id] = ((u_int) Utils::from_string(tokens[1]));
				F_Node * node = new F_Node(predictions[id],id);
				nodes[id] = node;
			}
		}

		for(int i=0;i<nbNodes;i++)
		{
			if(predictions.count(i) == 0)
			{
				int left = lefts[i];
				int right = rights[i];
				nodes[i]->children.push_back(nodes[left]);
				nodes[i]->children.push_back(nodes[right]);
			}
		}
		root = nodes[0];
	}
}

F_DTree::~F_DTree()
{

//cerr<<"try to f_tree deleted !"<<endl;
//	for(int i=0;i<bag.size();i++){
//		//bag.clear();
//		bag.erase(bag.begin()+i);
//	}

bag.clear();
//root=NULL;
delete root;
//delete trainSet;


//cerr<<"fdtree_delete minmax"<<endl;
//delete minmax[0];
//delete minmax[1];
//delete[] minmax;
//cerr<<"fin fdtree delete minmax"<<endl;
//delete trainSet;
//tree_temp=NULL;
//delete tree_temp;

//cerr<<"f_tree deleted !"<<endl;
}


void F_DTree::setListDim(vector<int> list){
	list_dim=list;
}

void F_DTree::setListSubspace(u_int* list){

	listsubspaceTree=list;

//	cerr<<"Liste recue:"<<endl;
//
//	for(int j=0;j<10;j++){
//	cerr<<listsubspaceTree[j]<<endl;
//}



}

void 	F_DTree::createFDTree(Node * node, F_Node * f_node){



	for(u_int i=0;i<node->getNbChildren();i++){
		Node * child = node->getChild(i);

		F_Node * f_n = NULL;



		if(child->is_leaf()){
			f_n = new F_Node(child->getPrediction(),child->getId());

		}
		else{
			f_n = new F_Node(child->getSplitRule(),child->getId());




		}



		f_node->children.push_back(f_n);

		if(!child->is_leaf()) createFDTree(child,f_n);

	}



}


vector<u_int>	F_DTree::getBag(){

return bag;

}

u_int	F_DTree::predict(Instance * inst){

//cerr<<"entree predict fdtree debug 1"<<endl;
if(rejet_nodes){



//cerr<<"description instance:"<<inst->getId()<<" size:"<<inst->getVectSimple().size()<<"\n";

vector<double> v=inst->getVectSimple();

int nbD=v.size();


//for(int j=0;j<v.size();j++){
//
//	cerr<<j<<":"<<v[j]<<endl;
//}

//cerr<<"entree predict fdtree debug 2"<<endl;
bool active_ss=(listsubspaceTree!=NULL);
//cerr<<"entree predict fdtree debug 3"<<endl;

if(active_ss){

int nbDim=list_dim.size();
//cerr<<"dim associees:"<<nbDim<<" /========================"<<endl;
//for(int j=0;j<nbDim;j++){
//cerr<<j<<":"<<list_dim[j]<<" => "<<v[j]<<endl;
//}
//
//
//cerr<<"\nsubspaces:"<<nbss<<" /========================"<<endl;
//for(int j=0;j<nbDim;j++){
//cerr<<j<<":"<<listsubspaceTree[j]<<endl;
//}

}
else{
	cerr<<" pas de listsubspace ou #ref ..."<<endl;
}
//inst->toString();

//cerr<<"debug 1:dim trainSet="<<nbD<<endl;

//cerr<<"entree predict fdtree debug 4"<<endl;
int found=0;
string bar="";
for(int i=0;i<nbD-1;i++){

//cerr<<"debug 1:"<<i<<endl;


	int d=i;

if(active_ss){
	d=list_dim[i];
}

//cerr<<"debug 2:index dim inst "<<i<<" index dim orig="<<d<<endl;
double val=inst->at(i);
double min_val=minmax[0][d];
double max_val=minmax[1][d];

//cerr<<"debug 3:"<<i<<endl;
if(val>max_val || val<min_val) {

//cerr<<"\nrejet_nodes inst:"<<"/inst="<<inst->getId()<<"/i/nbDim:"<<i<<"/"<<nbD<<" attribut"<<d<<" val="<<val<<" min="<<min_val<<" max="<<max_val;
//cerr<<" =>oulier"<<endl;
found++;
bar=bar+"=";
	//return OUTLIER;//return outlier only if passed all dimensions available ....
}//0:outlier
else{
	break;//found one dimension
}
//cerr<<"debug 4:"<<i<<endl;

}

//if(found>5){
//cout<<"\n\n"<<found<<"/"<<nbD-1<<"\n"<<bar<<"\n"<<endl;
//cin.get();
//}

if(found>=nbD){//rejected by all dimensions
	//cout<<"\n\nfoun !"<<endl;
	//cin.get();
	return OUTLIER;
}

//int d=node->splitRule->getAttId();
//cerr<<"debug 5"<<endl;

}
//cerr<<"entree predict fdtree debug 5"<<endl;
return recursPredict(inst, root);
}

u_int 	F_DTree::recursPredict(Instance * inst, F_Node * node){

//cerr<<"entree predict fdtree debug 6"<<endl;


if(node->splitRule == NULL){



	return node->prediction;

}




//cerr<<"entree predict fdtree debug 7"<<endl;
//if(rejet_nodes){
//
//int d=node->splitRule->getAttId();
//double val=inst->at(d);
//double min_val=minmax[0][d];
//double max_val=minmax[1][d];
//
////cerr<<"\nrejet_nodes:"<<d<<" "<<val<<" "<<min_val<<" "<<max_val;
//if(val>max_val || val<min_val) {
////	cerr<<" oulier"<<endl;
//	return 1;
//}//1:outlier
//
//
//}




u_int childInd = node->splitRule->evaluate(inst->at(node->splitRule->getAttId()));


return recursPredict(inst,node->children[childInd]);

}

void 	F_DTree::save(string filename, int id)
{
	ofstream file(filename.c_str());
	if(file.is_open())
	{
		for(u_int i=0;i<bag.size();i++)
		{
			file << Utils::to_string((int) bag[i]);
			file << " ";
		}
		file << "\n";
		file << Utils::to_string((int)nbNodes);
		file << "\n";
		file << (*root).fileToString().c_str();
		file.flush();
	}
	file.close();
}



